#函数式接口
Lambda表达式如何适配java的类型系统？每个Lambda表达式都适配被接口指定的类型.一个所谓的函数式接口必须包含`仅有一个抽象方法`声明.每个Lambda表达式必须符合这个抽象方法.因为默认方法不是抽象的，所以你可以随意增加至函数式接口.<br>
只要接口仅含有一个抽象方法，我们就可以把它作为Lambda表达式.为了确保你的接口符合要求，你应该增加`@FunctionalInterface`注解.只要你增加第二个抽象方法声明到接口，编译器感知到了注解就会抛出编译错误.<br>
例子：<br>
```java
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
```
```java
Converter<String, Integer> converter = (from) -> Integer.valueOf(from);
Integer converted = converter.convert("123");
System.out.println(converted);    // 123
```
记住：如果`@FunctionalInterface`注解忽略，代码也是有效的<br>
#方法和构造函数的引用
利用静态方法的引用，上面的代码可以进一步简化
```java
Converter<String, Integer> converter = Integer::valueOf;
Integer converted = converter.convert("123");
System.out.println(converted);    // 123
```
java8允许你通过关键词`::`传递对方法，构造函数的引用.上面的代码演示了怎么引用静态方法.同样，我们也可以引用对象方法
```java
class Something {
    String startsWith(String s) {
        return String.valueOf(s.charAt(0));
    }
}
```
```java
Something something = new Something();
Converter<String, String> converter = something::startsWith;
String converted = converter.convert("Java");
System.out.println(converted);    // "J"
```
让我们来看看怎么通过关键词`::`应用构造函数.首先我们定义一个有不同构造函数的对象
```java
class Person {
    String firstName;
    String lastName;

    Person() {}

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
```
接下来我们定义一个Person的工厂函数来创建新的Person<br>
```java
interface PersonFactory<P extends Person> {
    P create(String firstName, String lastName);
}
```
代替手工实现工厂方法，我们通过引用把这一切都粘合起来.
```java
PersonFactory<Person> personFactory = Person::new;
Person person = personFactory.create("Peter", "Parker");
```
我们通过`Persion::new`创建了一个Person构造函数的引用.java编译器靠匹配`PersonFactory.create`签名来选择正确的构造函数.
# Lambada范围


