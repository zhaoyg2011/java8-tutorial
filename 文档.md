#函数式接口
Lambda表达式如何适配java的类型系统？每个Lambda表达式都适配被接口指定的类型.一个所谓的函数式接口必须包含`仅有一个抽象方法`声明.每个Lambda表达式必须符合这个抽象方法.因为默认方法不是抽象的，所以你可以随意增加至函数式接口.<br>
只要接口仅含有一个抽象方法，我们就可以把它作为Lambda表达式.为了确保你的接口符合要求，你应该增加`@FunctionalInterface`注解.只要你增加第二个抽象方法声明到接口，编译器感知到了注解就会抛出编译错误.<br>
例子：<br>
```java
@FunctionalInterface
interface Converter<F, T> {
    T convert(F from);
}
```
```java
Converter<String, Integer> converter = (from) -> Integer.valueOf(from);
Integer converted = converter.convert("123");
System.out.println(converted);    // 123
```
记住：如果`@FunctionalInterface`注解忽略，代码也是有效的<br>
#方法和构造函数的引用
利用静态方法的引用，上面的代码可以进一步简化
```java
Converter<String, Integer> converter = Integer::valueOf;
Integer converted = converter.convert("123");
System.out.println(converted);    // 123
```
java8允许你通过关键词`::`传递对方法，构造函数的引用.上面的代码演示了怎么引用静态方法.同样，我们也可以引用对象方法
```java
class Something {
    String startsWith(String s) {
        return String.valueOf(s.charAt(0));
    }
}
```
```java
Something something = new Something();
Converter<String, String> converter = something::startsWith;
String converted = converter.convert("Java");
System.out.println(converted);    // "J"
```
让我们来看看怎么通过关键词`::`应用构造函数.首先我们定义一个有不同构造函数的对象
```java
class Person {
    String firstName;
    String lastName;

    Person() {}

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
```
接下来我们定义一个Person的工厂函数来创建新的Person<br>
```java
interface PersonFactory<P extends Person> {
    P create(String firstName, String lastName);
}
```
代替手工实现工厂方法，我们通过引用把这一切都粘合起来.
```java
PersonFactory<Person> personFactory = Person::new;
Person person = personFactory.create("Peter", "Parker");
```
我们通过`Persion::new`创建了一个Person构造函数的引用.java编译器靠匹配`PersonFactory.create`签名来选择正确的构造函数.
# Lambda范围
从Lambda表达式访问外部范围的变量非常相似匿名类.<br>
你可以访问本地外部范围的final变量，同样实例变量和类变量.<br>
* 访问局部变量<br>
我们可以从Lambda表达式外部范围读取本地final局部变量.
```java
final int num = 1;
Converter<Integer, String> stringConverter =
        (from) -> String.valueOf(from + num);

stringConverter.convert(2);     // 3
```
与匿名类不同的是，`num`不需要声明为final.下面的代码也是有效的:
```java
int num = 1;
Converter<Integer, String> stringConverter =
        (from) -> String.valueOf(from + num);

stringConverter.convert(2);     // 3
```
但是对编译来说，`num`必须隐式的为final.下面的代码不能通过编译.<br>
```java
int num = 1;
Converter<Integer, String> stringConverter =
        (from) -> String.valueOf(from + num);
num = 3;
```
* 访问字段和静态变量
跟局部变量不同，我们有在Lambda表达式中对实例字段和静态变量读写权限.这个行为对匿名类是非常典型的.
```java
class Lambda4 {
    static int outerStaticNum;
    int outerNum;

    void testScopes() {
        Converter<Integer, String> stringConverter1 = (from) -> {
            outerNum = 23;
            return String.valueOf(from);
        };

        Converter<Integer, String> stringConverter2 = (from) -> {
            outerStaticNum = 72;
            return String.valueOf(from);
        };
    }
}
```
* 访问默认接口方法
还记得在第一节Formula的例子吗？接口`Formula`定义了一个默认方法`sqrt`,它能够从每个Formula实例或者匿名类被访问.这不能在Lambda表达式中工作.<br>匿名方法不能在Lambda中被访问。下面代码不能编译.
```java
Formula formula = (a) -> sqrt( a * 100);
```
# 内置函数式接口
java8中内置了很多函数式接口.他们中的一些在java老的版本中就被熟知了,比如`Comparator`和`Runnable`.这些内置的接口通过`@FunntionalInterface`注解被扩展为能够支持Lambda表达式.<br>
但是java8也充满了新的函数式接口来使生活更容易.哪些新的函数式接口中的一些在Guava库中已经被熟知.即使你对Guava库熟悉了，你也应该近距离的看一下这些接口是怎样被一些有用的方法扩展的。
* 谓词 <br>
Predicates是单参数布尔值函数.这个接口包含了许多默认方法来使谓词转变为逻辑表达式（与或者非）.
```java
Predicate<String> predicate = (s) -> s.length() > 0;

predicate.test("foo");
predicate.negate().test("foo");

Predicate<Boolean> nonNull = Objects::nonNull;
Predicate<Boolean> isNull = Objects::isNull;

Predicate<String> isEmpty = String::isEmpty;
Predicate<String> isNotEmpty = isEmpty.negate();
```
* 函数 <br>
函数接口是接受单一参数并且产生一个结果.默认方法可以用来链接多个函数接口（compose,andThen）.
```java
Function<String,Integer> toInteger = Integer::valueOf;
Function<String,String> backToString = toInteger.andThen(String:valueOf);

backToString.apply("123");
```
* 生产者 <br>
Suppliers产生一个通用类型的结果。与Functions不同，Suppliers不接受参数。
```java
Supplier<Person> personSupplier = Person::new;
personSupplier.get();
```
* 消费者 <br>
消费者描述了对单个输入参数进行操作的行为.
```java
Consumer<Person> greeter = (p) -> System.out.println("hello," + p.firstName);
greeter.accept(new Person("zhao","yangang"));
```
* 比较器 <br>
比较器从老版本的java就熟知了.java 8 增加了一些默认方法至接口.
```java
Comparator<Person> comparator = (p1, p2) -> p1.firstName.compareTo(p2.firstName);

Person p1 = new Person("John", "Doe");
Person p2 = new Person("Alice", "Wonderland");

comparator.compare(p1, p2);             // > 0
comparator.reversed().compare(p1, p2);  // < 0
```
* Optionals <br>
 @todo<br>
#Streams
`java.util.Stream`描述了一个或者多个操作的流.
